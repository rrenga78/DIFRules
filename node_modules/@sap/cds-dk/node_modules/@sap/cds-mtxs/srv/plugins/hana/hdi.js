const { join } = require('path')
const { deploy, clean_env } = require('@sap/hdi-deploy/library')
const cds = require ('@sap/cds/lib')
const LOG = cds.log('mtx|deploy'), DEBUG = cds.debug('mtx|deploy')
const { fs, mkdirp } = cds.utils

exports.deploy = async (hana, tenant, cwd, options) => {
  const env = _hdi_env4(tenant,hana,options)
  DEBUG?.(`deployment directory: ${cwd}`)
  DEBUG?.(`effective HDI options:`, env.HDI_DEPLOY_OPTIONS)

  const logPath = join(cds.root, 'logs', `${cds.context.tenant}.log`)
  await mkdirp('logs')
  const writeStream = fs.createWriteStream(logPath)
  DEBUG?.('------------[BEGIN HDI-DEPLOY-OUTPUT]---------------')
  try {
    return await new Promise((resolve, reject) => {
        deploy(cwd, env, (error, response) => {
            if (error) return reject(error)
            if (response?.exitCode) {
                let message = `HDI deployment failed with exit code ${response.exitCode}`
                if (response.signal) message += `. ${response.signal}`
                return reject(new Error(message))
            }
            return resolve()
        }, {
          stderrCB: buffer => {
              LOG.error(buffer.toString())
              writeStream.write(buffer)
          },
          stdoutCB: buffer => {
              DEBUG?.(buffer.toString())
              writeStream.write(buffer)
          }
      })
    })
  } finally {
    DEBUG?.('-------------[END HDI-DEPLOY-OUTPUT]----------------')
    writeStream.end()
    LOG.info(`written deployment logs to ${logPath}`)
  }
}

const _hdi_env4 = (t,container,options)=>{
  const env = { ...clean_env(process.env), TARGET_CONTAINER:t }
  env.SERVICE_REPLACEMENTS = process.env.SERVICE_REPLACEMENTS

  const { hana=[], 'user-provided':up } = _parse_env ('VCAP_SERVICES')
  env.VCAP_SERVICES = JSON.stringify ({
    hana:[ { ...container, name:t, tenant_id:t }, ...hana ],
    'user-provided':up
  })

  const hdi_opts = _parse_env ('HDI_DEPLOY_OPTIONS', options)
  env.HDI_DEPLOY_OPTIONS = JSON.stringify (hdi_opts)
  return env
}
const _parse_env = (key, options) => {
  const val = process.env[key]; if (!val) return { ...options }
  try {
    return { ...JSON.parse (val), ...options }
  } catch(e) {
    e.message = `Invalid ${key} options: ${e.message} ${val}`
    e.code = e.statusCode = 400
    throw e
  }
}
