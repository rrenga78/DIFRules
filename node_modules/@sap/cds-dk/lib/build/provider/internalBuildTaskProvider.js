const fs = require('fs')
const path = require('path')
const cds = require('../../cds')
const { hasJavaNature, getDefaultModelOptions, BuildError, hasOptionValue, isClassicMtx, normalizePath } = require('../util')
const BuildTaskProvider = require('../buildTaskProvider')

const { FILE_EXT_CDS, BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_JAVA_CF, BUILD_TASK_NODEJS, BUILD_TASK_NODE_CF, BUILD_TASK_MTX,
    BUILD_TASK_PREFIX, BUILD_TASKS, BUILD_TASK_MTX_SIDECAR, MTX_SIDECAR_FOLDER, BUILD_TASK_MTX_EXTENSION, NODEJS_MODEL_EXCLUDE_LIST,
    IGNORE_DEFAULT_MODELS } = require("../constants")

class InternalBuildTaskProvider extends BuildTaskProvider {
    constructor(logger) {
        super()
        this._logger = logger
        // ensure that classic mtx is not used in combination with cds-dk@7
        if (isClassicMtx()) {
            throw new BuildError(`@sap/cds-mtx is deprecated and not supported by @sap/cds-dk >= 7.
Upgrade to @sap/cds-mtxs following the migration guide https://cap.cloud.sap/docs/guides/multitenancy/old-mtx-migration or install @sap/cds-dk version 6 instead.`)
        }
    }
    get logger() {
        return this._logger
    }

    providesTask(key) {
        return BUILD_TASKS.includes(key.for) || key.use && key.use.startsWith(BUILD_TASK_PREFIX)
        // REVISIT: do not support different build task implementations of the same build task ID defined by 'for'
        // return (BUILD_TASKS.includes(key.for) && !key.use) || (key.use && key.use.startsWith(BUILD_TASK_PREFIX))
    }

    async lookupTasks(tasks, dependencies) {
        return this._createTasks(tasks, dependencies)
    }

    async applyTaskDefaults(task) {
        const taskFor = InternalBuildTaskProvider._getForValueFromTask(task)
        task.for = task.for || taskFor
        task.use = task.use || `${BUILD_TASK_PREFIX}/${taskFor}`

        // src folder needs to be initialized first
        InternalBuildTaskProvider._setDefaultSrcFolder(task)

        InternalBuildTaskProvider._setDefaultModel(task)
    }

    getPluginClass(task) {
        return require(`./${InternalBuildTaskProvider._getForValueFromTask(task)}`)
    }

    async _createTasks(tasks, dependencies) {
        let db = typeof cds.env.folders.db === "string" ? [normalizePath(cds.env.folders.db)] : cds.env.folders.db
        let srv = typeof cds.env.folders.srv === "string" ? [normalizePath(cds.env.folders.srv)] : cds.env.folders.srv

        const dbOptions = {
            model: []
        }
        const srvOptions = {
            model: []
        }
        if (Array.isArray(db) && db.length > 0) {
            db = InternalBuildTaskProvider._getModuleFolder(db) || null
            if (!db && !dependencies) { // log once
                this.logger.debug("No database module found")
            }
        }
        if (Array.isArray(srv) && srv.length > 0) {
            srv = InternalBuildTaskProvider._getModuleFolder(srv) || null
            if (!srv && !dependencies) { // log once
                this.logger.debug("No service module found")
            }
        }

        // order of creation is relevant
        if (dependencies) {
            const mtxTask = tasks.find(task => task.for === BUILD_TASK_MTX || task.for === BUILD_TASK_MTX_SIDECAR)
            if (mtxTask) {
                //restore used tasks as they might have been filtered by 'cds build --for mtx'
                if (mtxTask._uses) {
                    mtxTask._uses.map(use => use.task).forEach(task => {
                        if (!tasks.includes(task)) {
                            tasks.push(task)
                        }
                    })
                }
                let dbTask = tasks.find(task => task.for === BUILD_TASK_HANA)
                if (!dbTask) {
                    //  db task might be missing if mtx task is enforced by 'cds build --for mtx'
                    dbTask = cds.env.build.tasks?.find(task => task.for === BUILD_TASK_HANA)
                    if (!dbTask) {
                        dbTask = this._createDbTask(db, dbOptions)
                    }
                    if (dbTask) {
                        tasks.push(dbTask)
                    }
                }
                if (dbTask && !mtxTask._uses?.map(use => use.task).includes(dbTask)) {
                    const use = { task: dbTask }
                    mtxTask._uses ? mtxTask._uses.push(use) : mtxTask._uses = [use]
                }
            }
        } else {
            !db && this.logger._debug && this.logger.debug(`project doesn't have a database module '${cds.env.folders.db}'`)
            !srv && this.logger._debug && this.logger.debug(`project doesn't have a service module '${cds.env.folders.srv}'`)

            // create hana build task
            const dbTask = this._createDbTask(db, dbOptions)
            if (dbTask) {
                tasks.push(dbTask)
            }
            // create java or node build task
            const srvTask = this._createSrvTask(srv, srvOptions)
            if (srvTask) {
                tasks.push(srvTask)
            }

            // create mtx build task
            const mtxTask = this._createMtxTask(srv)
            if (mtxTask) {
                tasks.push(mtxTask)
            }
        }
    }

    _createDbTask(src, taskOptions) {
        this.logger.debug("determining database kind")
        if (!src || InternalBuildTaskProvider._isMtxExtension()) {
            return null
        }
        let task = null
        if (this._useHana()) {
            this.logger.debug("found HANA database")
            // legacy build supports dest property
            const compileDest = cds.env.data?.dest
            if (compileDest) {
                //../db/src/gen
                // compileDest is relative to src folder in modular build - resolve correctly
                taskOptions.compileDest = path.relative(path.resolve(cds.root, src), path.resolve(cds.root, compileDest))
            }
            task = {
                src: src,
                for: BUILD_TASK_HANA,
                options: taskOptions
            }
        } else {
            this.logger.debug("found sqlite database - skipping HANA build task")
        }
        return task
    }

    _useHana() {
        if (cds.env.requires.db?.kind === "hana" || cds.env.requires.db?.dialect === "hana") {
            return true
        }
        // false if other db has been defined
        if (cds.env.requires.db?.kind) {
            return false
        }
        // check whether cds config represents a legacy build system config for which requires.db was not configured
        // Note: compat layer sets requires.db: {}
        const userEnv = cds.env.for("cds", cds.root, false)
        return userEnv && (userEnv.data?.model || userEnv.service?.model)
    }

    _createMtxTask(src) {
        this.logger.debug("determining MTX architecture")

        // preserve order of creation
        if (InternalBuildTaskProvider._isMtxExtension()) {
            this.logger.debug("MTX extension app")
            return { for: BUILD_TASK_MTX_EXTENSION }
        }

        if (InternalBuildTaskProvider._isMtxs()) {
            const sidecarPath = path.join(cds.root, MTX_SIDECAR_FOLDER)
            let sidecarEnv
            if (fs.existsSync(sidecarPath)) {
                sidecarEnv = cds.env.for("cds", sidecarPath)
            }
            if (
                cds.env.profiles?.includes('with-mtx-sidecar') || // new presets
                cds.env.requires["cds.xt.ModelProviderService"]?.external // for compatibility with former mtxs presets
            ) {
                this.logger.debug("MTX app with sidecar")
                if (!sidecarEnv) {
                    throw new BuildError(`MTX sidecar directory '${sidecarPath}' not existing. Custom build task configuration required if the folder is named differently.`)
                }
                if (!sidecarEnv.requires["cds.xt.ModelProviderService"]?._in_sidecar) {
                    if (sidecarEnv.profiles?.includes('mtx-sidecar')) {
                        // profile has been set, but cannot be resolved
                        throw new BuildError('MTX configuration cannot be resolved. Make sure up-to-date versions of @sap/cds-mtxs and @sap/cds are installed.')
                    }
                    throw new BuildError(`Invalid MTX sidecar configuration - profile 'mtx-sidecar' not set.`)
                }
                return { for: BUILD_TASK_MTX_SIDECAR }
            }

            if (sidecarEnv?.requires["cds.xt.ModelProviderService"]?._in_sidecar || sidecarEnv?.profiles?.includes('mtx-sidecar')) {
                throw new BuildError(`MTX sidecar requires profile 'with-mtx-sidecar' in project root configuration.`)
            }
            if (cds.env.requires["cds.xt.ModelProviderService"]?._in_sidecar || cds.env.profiles?.includes('mtx-sidecar')) {
                // cds build is executed in sidecar folder
                throw new BuildError(`Seems that you are executing 'cds build' in the 'mtx/sidecar' folder. Execute 'cds build' in the project root folder instead.`)
            }

            // mtxs nodejs app without sidecar
            if (!InternalBuildTaskProvider._hasJavaNature(src)) {
                this.logger.debug("MTX Nodejs app without sidecar")
                return {
                    for: BUILD_TASK_MTX,
                    src
                }
            }
        }
    }

    _createSrvTask(src, taskOptions) {
        this.logger.debug("determining implementation technology")
        if (!src || InternalBuildTaskProvider._isMtxExtension()) {
            return null
        }
        let task = null
        if (InternalBuildTaskProvider._hasJavaNature(src)) {
            task = this._createJavaTask(src, taskOptions)
        } else {
            task = this._createNodeTask(src, taskOptions)
        }
        return task
    }

    _createJavaTask(src, taskOptions) {
        this.logger.debug("found implementation technology Java")
        // legacy build supports dest property
        const compileDest = cds.env.service?.dest
        if (compileDest) {
            // compileDest is relative to src folder in modular build - resolve correctly
            taskOptions.compileDest = path.relative(path.resolve(cds.root, src), path.resolve(cds.root, compileDest))
        }
        return {
            src: src,
            for: BUILD_TASK_JAVA,
            options: taskOptions
        }
    }

    _createNodeTask(src, taskOptions) {
        this.logger.debug("found implementation technology Nodejs")
        return {
            src: src,
            for: BUILD_TASK_NODEJS,
            options: taskOptions
        }
    }

    static _isMtxExtension() {
        return !!cds.env.extends
    }

    /**
     * Distinguishes whether the Nodejs project is a Streamlined MTX (cds >=6) or an old MTX project.
     */
    static _isMtxs() {
        return cds.env.requires.toggles
            || cds.env.profiles.includes('with-mtx-sidecar')
            || cds.env.requires['cds.xt.ModelProviderService']
            || (typeof cds.env.requires.multitenancy === "object")
    }

    static _setDefaultSrcFolder(task) {
        switch (task.for) {
            case BUILD_TASK_HANA:
                task.src = task.src || normalizePath(cds.env.folders.db)
                break
            case BUILD_TASK_JAVA:
            case BUILD_TASK_JAVA_CF:
            case BUILD_TASK_NODEJS:
            case BUILD_TASK_NODE_CF:
                task.src = task.src || normalizePath(cds.env.folders.srv)
                break
            case BUILD_TASK_FIORI:
                task.src = task.src || normalizePath(cds.env.folders.app)
                break
            case BUILD_TASK_MTX_SIDECAR:
                task.src = task.src || MTX_SIDECAR_FOLDER
                break
            case BUILD_TASK_MTX_EXTENSION:
                task.src = task.src || "."
                break
            case BUILD_TASK_MTX:
                // mtxs with nodejs, but without sidecar
                task.src = task.src || normalizePath(cds.env.folders.srv)
                break
            default:
                throw new Error(`Unknown build task '${task.use || task.for}'`)
        }
    }

    static _setDefaultModel(task) {
        let taskModelPaths = task.options?.model
        if (taskModelPaths && !Array.isArray(taskModelPaths)) {
            taskModelPaths = [taskModelPaths]
        }
        const toggles = cds.env.features.folders
        const allowList = new RegExp(`^@sap/cds${toggles ? '|^' + toggles.replace('*', '') : ''}`)
        task.options = task.options || {}
        let defaultModelPaths = []
        if (taskModelPaths?.length) {
            if (!hasOptionValue(task.options?.[IGNORE_DEFAULT_MODELS], true)) {
                defaultModelPaths = getDefaultModelOptions().filter(p => p.match(allowList))
            }
        } else {
            defaultModelPaths = getDefaultModelOptions()
            defaultModelPaths.push(task.src)
            if (hasOptionValue(task.options?.[IGNORE_DEFAULT_MODELS], true)) {
                // all default models except the built-in models
                defaultModelPaths = defaultModelPaths.filter(p => !p.match(allowList))
            }
        }
        // REVISIT: filter nodejs bootstrap service models for Java - issues/12770#issuecomment-1805719
        if (this._hasJavaNature()) {
            defaultModelPaths = defaultModelPaths.filter(p => !NODEJS_MODEL_EXCLUDE_LIST.includes(p))
        }
        if (defaultModelPaths.length) {
            task.options.model = [...new Set(taskModelPaths?.length ? taskModelPaths.concat(defaultModelPaths) : defaultModelPaths)]
        }
    }

    /**
     * Returns whether this project is a java project or not.
     * @param {string} srv - the folder name of the service module
     */
    static _hasJavaNature(srv = cds.env.folders.srv) {
        srv = this._getModuleFolder(Array.isArray(srv) ? srv : [srv])
        return hasJavaNature([cds.root, srv && path.join(cds.root, srv)])
    }

    static _getForValueFromTask(task) {
        return task.for ? task.for : task.use && task.use.substring(BUILD_TASK_PREFIX.length + 1)
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(cds.root, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = InternalBuildTaskProvider
