const fs = require('fs')
const path = require('path')
const cds = require('../cds')
const BuildTaskProviderFactory = require('./buildTaskProviderFactory')
const { hasJavaNature, getProperty, redactCredentials, flatten, getDefaultModelOptions } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_JAVA_CF, BUILD_TASK_JAVA } = require("./constants")
const term = require('../util/term')

class BuildTaskFactory {
    constructor(options) {
        this._providerFactory = new BuildTaskProviderFactory(options)
    }
    get providerFactory() {
        return this._providerFactory
    }
    get logger() {
        return this.providerFactory.logger
    }
    get options() {
        return this.providerFactory.options
    }

    // the following order for determining build tasks is used
    // 1. create from command line input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks() {
        const tasks = await this._createTasks()

        // log build tasks
        let tasksOutput = "{\n  build: {\n    target: " + term.info("'" + cds.env.build.target + "'") + ",\n    tasks: [\n"
        for (let i = 0; i < tasks.length; i++) {
            tasksOutput += "      " + BuildTaskFactory._stringifyTask(tasks[i]) + (i + 1 < tasks.length ? ",\n" : "\n")
        }
        tasksOutput += "    ]\n  }\n}\n"
        this.logger.log(tasksOutput)

        // for testing purposes
        this.logger.debug("cds.env used for build:")
        this.logger._debug && this.logger.debug(redactCredentials(cds.env))

        // always resolve tasks for input validation
        const resolvedTasks = this.providerFactory.resolveTasks(tasks)
        if (this.options.resolve) {
            return resolvedTasks
        }
        return tasks
    }

    createPlugin(task) {
        return this.providerFactory.createPlugin(task)
    }

    async _createTasks() {
        this.logger.debug(`determining build tasks for project [${cds.root}].`)

        // clearing model cache (details https://github.tools.sap/cap/cds/pull/181) is no longer required
        // because of changes https://github.tools.sap/cap/cds/pull/1121
        // cds.resolve.cache = {}

        let tasks = BuildTaskFactory._getExistingTasks()
        if (tasks.length === 0) {
            tasks = await this.providerFactory.lookupTasks()
        } else {
            // 1. apply default values including task.for and task.use and ensure that for all tasks a provider exists - throwing error otherwise
            await this.providerFactory.applyTaskDefaults(tasks)
            // ensure that dependencies get wired up before filtering
            await this.providerFactory.lookupTasks(tasks, true)
        }

        // 3. filters the list of build tasks and adapts according to given CLI options
        // Note: A new task might get created, e.g. 'cds build --for hana' will enforce a hana build even if sqlite has been configured
        let existingTasks = tasks
        tasks = this._applyCliOptionsFilter(tasks)
        if (tasks.length === 0) {
            return tasks
        }
        // a new array is returned to indicate new build tasks have been created
        if (tasks !== existingTasks) {
            // a different task shall be executed
            await this.providerFactory.applyTaskDefaults(tasks)
        }

        // 2. add dependencies
        existingTasks = [...tasks]
        await this.providerFactory.lookupTasks(tasks, true)
        if (tasks.length > existingTasks.length) {
            const newTasks = tasks.filter(task => !existingTasks.includes(task))
            // a dependant task was added
            this._applyCliOptions(newTasks)
        }

        // obligatory task defaults shared by all tasks
        BuildTaskFactory._applyCommonTaskDefaults(tasks)

        this._setDefaultBuildTargetFolder(tasks)
        return tasks
    }

    static _getExistingTasks() {
        return Array.isArray(getProperty(cds.env, 'build.tasks')) ? JSON.parse(JSON.stringify(cds.env.build.tasks)) : []
    }

    static _applyCommonTaskDefaults(tasks) {
        const modelPaths = getDefaultModelOptions()

        tasks.forEach(task => {
            this._setTaskModelOptions(task, modelPaths)
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    _setDefaultBuildTargetFolder(tasks) {
        const task = tasks.find(task => task.for === BUILD_TASK_JAVA_CF || task.for === BUILD_TASK_JAVA)
        const srv = task ? task.src : BuildTaskFactory._getModuleFolder(flatten([cds.env.folders.srv])) || "srv"

        // Java projects use "." as the default build target folder
        if (hasJavaNature([path.join(cds.root, srv), cds.root]) && BuildTaskFactory._adaptBuildTargetSettingForJava()) {
            this.logger.debug("using inplace build for java project instead of default staging build")
        }
    }

    /**
    * Use inplace build for java projects if build.target has not been configured.
    * @returns {boolean} true if changed, false otherwise
    */
    static _adaptBuildTargetSettingForJava() {
        if (cds.env.build.target !== ".") {
            // filter user settings of cds.env
            const userEnv = cds.env.for("cds", cds.root, false)

            // use helper as env.build might be undefined
            if (!userEnv.build?.target) {
                cds.env.build.target = "."
                return true
            }
        }
        return false
    }

    _applyCliOptionsFilter(tasks) {
        const options = this.options
        // filter tasks using either option for, use, src
        let resultTasks = tasks.filter(task => {
            return (!options.use || options.use === task.use)
                && (!options.for || options.for === task.for)
                && (!options.src || options.src === task.src)
        })
        if (resultTasks.length === 0) {
            if (options.for || options.use) {
                const task = this.providerFactory.getTask(options.for ? { for: options.for } : { use: options.use })
                if (options.src) {
                    task.src = options.src
                }
                resultTasks.push(task)
            }
        } else if (resultTasks.length <= tasks.length) {
            // return the same array as long as it contains a subset of the given tasks
            tasks.length = 0
            resultTasks.forEach(task => tasks.push(task))
            resultTasks = tasks
        }
        this._applyCliOptions(resultTasks)
        return resultTasks
    }

    _applyCliOptions(tasks) {
        const options = this.options
        // apply remaining cli options to filtered tasks
        tasks.forEach(task => {
            if (options.dest) {
                task.dest = options.dest
            }
            if (options.opts) {
                const opts = BuildTaskFactory._scanTaskOptionParams(options.opts)
                task.options = task.options ? Object.assign(task.options, opts) : opts
            }
        })
    }

    static _setTaskModelOptions(task, defaultModelPaths) {
        task.options = task.options || {}
        if (!task.options.model || Array.isArray(task.options.model) && task.options.model.length === 0) {
            defaultModelPaths = new Set(defaultModelPaths)
            if (task.src) {
                defaultModelPaths.add(task.src)
            }
            task.options.model = [...defaultModelPaths]
        } else if (!Array.isArray(task.options.model)) {
            task.options.model = [task.options.model]
        }
    }

    static _stringifyTask(task) {
        // ensures identical order of properties
        const order = ["for", "use", "src", "dest", "options"]
        const keys = Object.keys(task).filter(key => order.includes(key)).sort((a, b) => order.indexOf(a) - order.indexOf(b))

        return keys.reduce((acc, key, i) => {
            const prefix = acc !== '{' ? ', ' : (i === 0 ? ' ' : '')
            if (!key.startsWith('_')) {
              // render either "for" OR "use" value
              if (key in { src: 1, for: 1 } || (!task.for && key === 'use')) {
                return `${acc}${prefix}${key}: ${term.info(`'${task[key]}'`)}`
              } else if (key === 'options') {
                const options = Object.entries(task.options)
                  .map(([key, value]) => {
                    if (Array.isArray(value)) {
                      return `${key}: [${value.map(v => term.info(`'${v}'`)).join(', ')}]`
                    } else if (typeof value === 'object') {
                      const nested = Object.entries(value)
                        .map(([key, value]) => `${key}: ${term.info(`'${value}'`)}`)
                        .join(', ')
                      return `${key}: { ${nested} }`
                    } else {
                      return `${key}: ${term.info(`'${value}'`)}`
                    }
                  })
                  .join(', ')
                return `${acc}${prefix}${key}: { ${options} }`
              } else if (key !== 'use') {
                return `${acc}${prefix}${key}: ${term.info(`'${task[key]}'`)}`
              }
            }
            return acc
          }, '{') + '}'
    }

    static _scanTaskOptionParams(optsParams) {
        // need to create new regex every call since a constant would keep the match state
        const quoteRegex = /([\w-]+)=([\w/.-]+|\[([\w/,.-]+)\])/g

        // captures a=1             => a:1
        //          a=[x,y,z]       => a:[x,y,z]
        //          a=1,b=[x,y,z]   => a:1 b=[x,y,z]
        let match = quoteRegex.exec(optsParams)
        const taskOptions = {}

        while (match != null) {
            const key = match[1]
            const value = match[3] || match[2]
            const valueArray = value.split(",")
            taskOptions[key] = valueArray.length > 1 ? valueArray.map((entry) => entry.trim()) : value
            match = quoteRegex.exec(optsParams)
        }
        return taskOptions
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(cds.root, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = BuildTaskFactory
