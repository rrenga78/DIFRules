const path = require('path');

const term = require('../util/term');

const { OPTIONS, COMMAND_INIT, PROJECT_FILES, REGEX_PROJECT_NAME } = require('./constants')
const {
    NODEJS, JAVA,
    HANA, APPROUTER, XSUAA, KIBANA, ENTERPRISE_MESSAGING,
    MTA, MULTITENANCY, PIPELINE,
    TINY_SAMPLE, SAMPLE
 } = OPTIONS

const cds = require('../cds'), { exists, readdir } = cds.utils
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) ? console.debug : undefined

module.exports = class CDSGenerator {
    constructor() {
        this.cwd = process.cwd();

        this.uiConfig = [{
            title: 'Project Name',
            description: 'Enter your project name.',
            default: '',
            target: 'projectName',
            validate: async (value) => {
                try {
                    cds.root = path.resolve(this.cwd, value || '.');

                    await this._validateProjectName(value);
                    await this._validateProjectFolder(path.join(this.cwd, value), this.cwd);
                } catch (e) {
                    return e
                }

                return true;
            },
            guiOptions: {
                hint: 'This name is restricted to certain characters. A valid project name is compatible across platforms.',
                mandatory: true
            }
        }, {
            title: 'Type',
            description: `Select your runtime.`,
            default: NODEJS,
            choices: [
                { name: 'Node.js', value: NODEJS },
                { name: 'Java', value: JAVA }
            ],
            multiple: false,
            target: 'add',
            guiOptions: {
                hint: `The preferred runtime can't be changed afterwards. To use a different runtime, create a new project.`,
                mandatory: true
            }
        }, {
            title: 'Features',
            description: 'Choose productive runtime capabilities for your application.',
            default: '',
            choices: [
                { name: 'SAP HANA Cloud', value: HANA },
                { name: 'SAP Application Router', value: APPROUTER },
                { name: 'User Authentication via XSUAA', value: XSUAA },
                { name: 'Kibana Logging Dashboard', value: KIBANA },
                { name: 'SAP BTP Event Mesh', value: ENTERPRISE_MESSAGING }
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
            }
        }, {
            title: 'Deployment',
            description: 'Choose which way to deploy your project.',
            default: '',
            choices: [
                { name: 'Cloud Foundry: MTA Deployment', value: MTA },
                // { name: 'Kyma: Helm Deployment', value: HELM },
                { name: 'Multitenancy', value: MULTITENANCY },
                { name: 'CI/CD Pipeline Integration', value: PIPELINE },
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
            }
        }, {
            title: 'Samples',
            description: `Add sample content to your project.`,
            default: '',
            choices: [
                { name: 'Minimal Sample', value: TINY_SAMPLE },
                { name: 'Extended Sample with UI', value: SAMPLE }
            ],
            multiple: true,
            target: 'add',
            guiOptions: {
                hint: 'Speed up your ramp-up phase with sample files in your project.'
            }
        }]
    }

    /**
     * @param {string} facets, comma separated list of templates, no blanks
     * @param {any} options, additional options
     */
    async addCmd(facets) {
        if (!facets) throw 'You must specify a facet to add to the project.'

        this._initialize(null);
        this._greetings();

        if (!PROJECT_FILES.find(exists)) {
            throw `The current folder doesn't seem to contain a project. None of the following files found: ${PROJECT_FILES.join(', ')}.`
        }

        await this._process();
        await this.stepEnd();
    }

    /**
     * @param {string} projectName, the project name
     */
    async initCmd(projectName) {
        await this.stepInit(projectName);
        await this.stepEnd();
    }

    async stepInit(projectName, options) {
        if (options) {
            // called from CAP generator with options
            cds.cli = {
                command: COMMAND_INIT,
                // keep caller independent from internal names
                options: {
                    cwd: options.cwd,
                    add: options.add
                }
            }
        }

        this._initialize(projectName);
        this._greetings();

        await this._process();
    }

    _initialize(projectName) {
        const { options } = cds.cli
        this.cwd = options.cwd || process.cwd();
        cds.root = path.resolve(this.cwd, projectName || '.');
        this.projectName = path.basename(cds.root);

        this._cleanupOptions();
    }

    _greetings() {
        if (cds.cli.command === COMMAND_INIT) {
            const relativeProjectPath = path.relative(this.cwd, cds.root)
            const folderName = relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder'
            console.log(`Creating new CAP project in ${term.bold(folderName)}\n`)
        }
        if (cds.cli.options.for && typeof cds.cli.options.for !== 'string') {
            throw 'The --for argument must not be empty.'
        }
        if (cds.cli.options.force) {
            console.log(`Using '--force' ... existing files will be overwritten`)
        }
    }

    async _process() {
        DEBUG?.(`Project path: ${cds.root}`);

        await this._validateOptions();
        await this._fillTemplateList();

        for (const template of this.templateList) {
            console.log(`Adding feature '${template.name}'...`);
            await template.run();
            await template.runDependentMerging();
            await template.runRelatedMerging();
        }

        if (cds.cli.command === COMMAND_INIT) {
            const relativeProjectPath = path.relative(this.cwd, cds.root)
            let message = 'Successfully created project.'
            if (relativeProjectPath) {
                message = message + ` Continue with '${term.bold('cd ' + relativeProjectPath)}'.`
            }
            console.log('\n' + message)
        } else {
            console.log(`\nSuccessfully added features to your project.`)
        }
    }

    async _createTemplate(filename) {
        try {
            const TemplateClass = require(`./template/${filename}`);
            return new TemplateClass(this);
        } catch (err) {
            if (err.code === 'MODULE_NOT_FOUND') {
                const entries = (await readdir(path.join(__dirname, 'template')))
                    .filter(entry =>
                        !entry.startsWith('_') &&
                        !entry.endsWith('.js') &&
                        entry !== 'nodejs' &&
                        entry !== 'java'
                    );
                const fuzzySearch = require('../../bin/util/fuzzySearch');
                const [bestMatch] = fuzzySearch(filename, entries);
                throw `Unknown facet '${term.bold(filename)}'. Did you mean ${term.bold(`cds add ${bestMatch}`)}?\n\nHaven't found the proper facet yet? Here are all supported facets:\n\n  ${term.bold(entries.join('\n  '))}\n`
            }
            throw err;
        }
    }

    async _fillTemplateList() {
        const templates = new Map
        const { command, options, argv } = cds.cli

        const facets = command === COMMAND_INIT ? options.add : new Set(argv[0].split(','))

        for (let facet of facets) {
            // Compat
            if (facet === 'sample-tiny') facet = 'tiny-sample'
            if (facet === 'kibana-logging') facet = 'kibana'
            if (facet === 'postgresql') facet = 'postgres'

            if (!templates.has(facet)) {
                const template = await this._createTemplate(facet)
                if (await template.canRun()) {
                    DEBUG?.(`Adding feature '${template.name}'`)
                    templates.set(facet, template)
                    const dependencies = await template.getDependencies()
                    dependencies?.forEach(d => facets.add(d))
                }
            }
        }

        const cmds = Object.values(OPTIONS)
        this.templateList = Array.from(templates.entries())
            .sort(([a], [b]) => cmds.indexOf(a) - cmds.indexOf(b))
            .map((entry) => entry[1])

        // check debug to avoid lengthy computation when not in debug mode
        DEBUG?.(`Features: ${this.templateList.map(({name}) => name).join(', ')}`);
    }

    // CAP Generator API
    async stepEnd() {
        for (const template of this.templateList) {
            await template.finalize();
        }
    }

    _cleanupOptions() {
        let tokens = [];

        const { options } = cds.cli
        if (typeof options.add === 'string') {
            tokens = options.add.split(/[,\s+]/g);

        } else if (Array.isArray(options.add)) {
            tokens = options.add

        } else if (options.add instanceof Set) {
            tokens = [...options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            token = token.replace(/\s+/g, '');
            const tokens = token.split(':'), [facet] = tokens
            if (tokens.length > 1) {
                if (options[facet]) {
                    options[facet].add(token);
                } else {
                    options[facet] = new Set([token]);
                }
            }
            return facet;
        }).filter(Boolean);

        // set is ordered ... always
        options.add = new Set(trimmedTokens);

        if (cds.cli.command === COMMAND_INIT && !options.add.has(JAVA)) {
            options.add.add(NODEJS);
        }

        this._checkAdditionalOptions();
    }

    _checkAdditionalOptions() {
        const { options } = cds.cli
        for (const [key] of Object.entries(options)) {
            const keySplit = key.split(/:/)
            if (keySplit.length === 2) {
                if (!options.add.has(keySplit[0])) {
                    console.log(`ignoring option ${key} since ${keySplit[0]} is not part of specified feature list: ${Array.from(options.add).join(', ')}`)
                }
            }
        }
    }

    async _validateOptions() {
        const { options, command } = cds.cli
        if (options.force) {
            return;
        }

        if (command === COMMAND_INIT) {
            await this._validateProjectName(this.projectName);
            await this._validateProjectFolder(this.cwd);
        }
    }

    async _validateProjectName(projectName) {
        if (!projectName) {
            throw 'Specify a project name.'
        }

        // remove duplicates by using a set
        const invalidChars = new Set(projectName.match(REGEX_PROJECT_NAME));
        switch (invalidChars.size) {
            case 0:
                break;
            case 1:
                throw `Project name ${projectName} contains an invalid character (${[...invalidChars].join(', ')}). Specify a different project name.`
            default:
                throw `Project name ${projectName} contains invalid characters (${[...invalidChars].join(', ')}). Specify a different project name.`
        }
    }

    async _validateProjectFolder(cwd) {
        const existingProjectFile = PROJECT_FILES.find(exists)
        if (existingProjectFile) {
            let message;
            if (cwd === cds.root) {
                message = `You seem to be working in a project which is already initialized. Use ${term.bold('cds add')} to add more features.`;
            } else {
                message = `You seem to be trying to initialize an existing project. Use a different project name instead.`;
            }
            throw `${message}\nDetails: File '${existingProjectFile}' exists in the project folder which indicates an existing project. Use ${term.bold('cds add')} to add more features.`
        }
    }
}
