const { join } = require('path')
const cds = require('../../../cds')
const { read, write, exists, rmdir, copy } = cds.utils
const { readProject } = require('../../util/projectReader')
const { mergeJSON, mergeYAML, removeFromYAML, removeFromYAMLArray } = require('../../util/merge')
const mvn = require('../../util/mvn')
const { parseMd5File, writeMd5File } = require('../../util/md5')

const { OPTIONS: { JAVA } } = require('../../constants')

const { srvNode4, srvJava4, hdbDeployer, serviceManager, hdiContainer, mtxSidecar4 } = require('../_merging/registry-mta')

module.exports = class HanaTemplate extends require('../templateBase') {

    static hasFacet(env) {
        return env.requires?.db?.kind === 'hana'
    }

    async run() {
        const project = await readProject()
        const { isJava, configFile, db } = project
        project.shortcut = !(await read(configFile)).cds?.requires?.db?.kind

        // REVISIT: Let cds build generate by default
        const hdiConfigPath = join(db.folder, 'src', '.hdiconfig')
        const hdiConfigTemplatePath = join(__dirname, 'files', 'src', '.hdiconfig')
        await mergeJSON(hdiConfigPath, hdiConfigTemplatePath)

        // REVISIT: Let csd build generate by default
        const undeployJSONPath = join(db.folder, 'undeploy.json')
        const undeployJSONTemplatePath = join(__dirname, 'files', 'undeploy.json')
        await mergeJSON(undeployJSONPath, undeployJSONTemplatePath)

        if (isJava) {
            await copy(join(__dirname, 'files', 'db')).to(db.folder)
            // REVISIT: shouldn't behave differently during cds init
            // if called during cds init the project generation call to AT will add settings
            if (!cds.cli.options.add.has(JAVA)) await mvn.execMvn(mvn.getAddHanaCmdArgs())
        }

        await mergeJSON(configFile, join(__dirname, 'files', 'package.json.hbs'), project, { forceOverwrite: true }) // REVISIT: forceOverwrite: true as default?

        const packageJson = exists('package.json') ? await read('package.json') : null
        if (packageJson?.dependencies) {
            delete packageJson.dependencies['@sap/hana-client']
            await write('package.json', packageJson, { spaces: 2 })
        }
    }

    async runDependentMerging(context = {}) {
        const project = await readProject()
        const { hasMta, hasHelm, hasHtml5Repo, isJava, isMultitenant, srvPath } = project

        if (hasMta) {
            const srv = (isJava ? srvJava4 : srvNode4)(srvPath)
            const db = isMultitenant ? serviceManager : hdiContainer
            const deletions = isMultitenant ? [{
                item: hdbDeployer,
                relationships: [{
                    removeProperty: 'name',
                    allWithin: ['modules', 'requires', 'name'],
                }]
            }, {
                item: hdiContainer,
                relationships: [{
                    removeProperty: 'name',
                    allWithin: ['modules', 'requires', 'name'],
                }]
            }] : []

            const relationships = [{
                insert: [db, 'name'],
                into: [srv, 'requires', 'name']
            }]

            if (isMultitenant) {
                relationships.push({
                    insert: [serviceManager, 'name'],
                    into: [mtxSidecar4(isJava ? 'mtx/sidecar' : 'gen/mtx/sidecar'), 'requires', 'name']
                })
            } else {
                relationships.push({
                    insert: [hdiContainer, 'name'],
                    into: [hdbDeployer, 'requires', 'name']
                })
            }

            const modules = isMultitenant ? [srv] : [srv, hdbDeployer]

            await mergeYAML('mta.yaml', join(__dirname, 'files', 'mta.yaml.hbs'), project, {
                additions: [...modules, db].filter(a => a), deletions, relationships
            })
        }

        if (hasHelm) {
            //in case facet is being added to the already exisiting charts folder
            let shouldUpdateTrackingFile = false;
            if(Object.keys(context).length == 0){
                shouldUpdateTrackingFile = true;
                context.oldTrackingData = context.newTrackingData = await parseMd5File(join('chart', '.cds-add-helm-files.md5'));
            }

            const HelmTemplate = require(`../helm`);
            const helmTemplate = new HelmTemplate(context.oldTrackingData, context.newTrackingData);

            if(isMultitenant){
                shouldUpdateTrackingFile = true;

                // remove hana entries from values.yaml
                await removeFromYAML(join('chart', 'values.yaml'), ['hana-deployer', 'srv.bindings.db', 'hana']);

                // remove hana entries from Chart.yaml
                await removeFromYAMLArray(join('chart', 'Chart.yaml'), 'dependencies', 'hana-deployer');

                // remove content-deployment subchart if html5Repo doesn't exist
                if(!hasHtml5Repo) {
                    const contentDeploymentEntriesPattern = "charts/content-deployment/"
                    this.removeEntriesFromContext(context, contentDeploymentEntriesPattern);

                    const contentDeploymentSubchartPath = join('chart', 'charts', 'content-deployment');
                    if(exists(contentDeploymentSubchartPath)) {
                        await rmdir(contentDeploymentSubchartPath);
                    }
                }

                //remove dependency since mtx plugin is added
                const isInternal = await helmTemplate.isInternal();
                await mergeYAML(
                    join('chart', 'Chart.yaml'),
                    {
                        dependencies: [
                            {
                                name: 'service-instance',
                                alias: 'hana',
                                version: '>0.0.0',
                                ...(isInternal) && { repository: 'https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz' }
                            }
                        ]
                    },
                    project,
                    { deletions: [{
                        item: {
                            in: `dependencies`,
                            where: [{
                                property: 'alias',
                                isEqualTo: 'hana'
                            }]
                        }
                    }]}
                )
            } else {
                await mergeYAML(
                    join('chart', 'values.yaml'),
                    join(__dirname, 'files', 'values.yaml.hbs'),
                    project
                )

                // copy content deployment chart if it is not present
                shouldUpdateTrackingFile = shouldUpdateTrackingFile | await helmTemplate.addSubChart('content-deployment');

                // add dependency entry in chart.yaml
                await helmTemplate.addDependency('content-deployment', 'hana-deployer');

                // add service instance chart if it is not present
                shouldUpdateTrackingFile = shouldUpdateTrackingFile | await helmTemplate.addSubChart('service-instance');

                // add dependency entry in chart.yaml
                await helmTemplate.addDependency('service-instance', 'hana');
            }
            if(shouldUpdateTrackingFile) await writeMd5File(join('chart', '.cds-add-helm-files.md5'), context.newTrackingData);
        }
    }

    // REVISIT: tracking data massaging is getting too much -> revisit md5 tracking
    removeEntriesFromContext(context, key) {
        Object.keys(context.oldTrackingData).forEach(fileName => {
            if (fileName.startsWith(key)) {
              delete context.oldTrackingData[fileName]
            }
        })

        Object.keys(context.newTrackingData).forEach(fileName => {
            if (fileName.startsWith(key)) {
              delete context.newTrackingData[fileName]
            }
        })
    }
}
